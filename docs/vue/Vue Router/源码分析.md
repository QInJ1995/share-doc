# 源码分析

Vue Router 是 Vue.js 官方的路由管理器，用于构建单页应用。它的源码主要包括以下几个核心模块：

1. 安装插件：通过 Vue.use() 安装插件。
2. 路由创建：通过 new VueRouter() 创建路由实例。
3. 路由匹配：通过 matcher 实现路由的匹配。
4. 导航守卫：处理路由的导航过程。
5. 视图渲染：根据匹配结果渲染对应的组件。

## 1. 安装插件

Vue Router 作为一个插件，需要通过 Vue.use(VueRouter) 进行安装：

```javaScript
VueRouter.install = function (Vue) {
  if (VueRouter.install.installed) return;
  VueRouter.install.installed = true;

  // 保存 Vue 构造函数引用
  _Vue = Vue;

  // 注册全局组件 <router-view> 和 <router-link>
  Vue.component('RouterView', View);
  Vue.component('RouterLink', Link);

  // 在 Vue 实例中混入 beforeCreate 钩子
  Vue.mixin({
    beforeCreate() {
      if (this.$options.router) {
        this._routerRoot = this;
        this._router = this.$options.router;
        this._router.init(this);
        Vue.util.defineReactive(this, '_route', this._router.history.current);
      } else {
        this._routerRoot = (this.$parent && this.$parent._routerRoot) || this;
      }
    }
  });

  // 在 Vue 原型上定义 $router 和 $route
  Object.defineProperty(Vue.prototype, '$router', {
    get() {
      return this._routerRoot._router;
    }
  });

  Object.defineProperty(Vue.prototype, '$route', {
    get() {
      return this._routerRoot._route;
    }
  });
};
```

关键点

- 全局组件注册：&lt;router-view&gt; 和 &lt;router-link&gt; 用于渲染匹配的视图和创建导航链接。
- 混入机制：在 beforeCreate 生命周期钩子中，判断是否有 router 选项，有则初始化路由。
- 响应式数据：使用 Vue.util.defineReactive 使当前路由响应式。

## 2. 路由创建

使用 new VueRouter(options) 创建路由实例：

```javaScript
class VueRouter {
  constructor(options = {}) {
    this.app = null;
    this.apps = [];
    this.options = options;
    this.beforeHooks = [];
    this.resolveHooks = [];
    this.afterHooks = [];
    this.matcher = createMatcher(options.routes || [], this);

    let mode = options.mode || 'hash';
    this.mode = mode;

    switch (mode) {
      case 'history':
        this.history = new HTML5History(this, options.base);
        break;
      case 'hash':
        this.history = new HashHistory(this, options.base, this.fallback);
        break;
      case 'abstract':
        this.history = new AbstractHistory(this, options.base);
        break;
      default:
        throw new Error(`invalid mode: ${mode}`);
    }
  }

  init(app) {
    this.apps.push(app);

    if (this.app) {
      return;
    }

    this.app = app;

    const history = this.history;

    if (history instanceof HTML5History) {
      history.transitionTo(history.getCurrentLocation());
    } else if (history instanceof HashHistory) {
      const setupHashListener = () => {
        history.setupListeners();
      };
      history.transitionTo(
        history.getCurrentLocation(),
        setupHashListener,
        setupHashListener
      );
    }

    history.listen(route => {
      this.apps.forEach(app => {
        app._route = route;
      });
    });
  }
}
```

关键点

- 路由模式：支持三种模式：hash、history、abstract。
- matcher：负责根据路由配置生成路由映射。
- 初始化：调用 init 方法建立初始路由，并设置监听。

## 3. 路由匹配

路由匹配由 createMatcher 函数实现，它根据路由配置生成匹配函数：

```javaScript
function createMatcher(routes, router) {
  const { pathList, pathMap, nameMap } = createRouteMap(routes);

  function addRoutes(routes) {
    createRouteMap(routes, pathList, pathMap, nameMap);
  }

  function match(raw, currentRoute, redirectedFrom) {
    const location = normalizeLocation(raw, currentRoute, false, router);
    const { name } = location;

    if (name) {
      const record = nameMap[name];
      if (!record) return _createRoute(null, location);
      const paramNames = record.regex.keys
        .filter(key => !key.optional)
        .map(key => key.name);

      location.params = location.params || {};

      if (currentRoute && typeof currentRoute.params === 'object') {
        for (const key in currentRoute.params) {
          if (!(key in location.params) && paramNames.indexOf(key) > -1) {
            location.params[key] = currentRoute.params[key];
          }
        }
      }

      location.path = fillParams(record.path, location.params, `named route "${name}"`);
      return _createRoute(record, location, redirectedFrom);
    } else if (location.path) {
      location.params = {};
      for (let i = 0; i < pathList.length; i++) {
        const path = pathList[i];
        const record = pathMap[path];
        if (matchRoute(record.regex, location.path, location.params)) {
          return _createRoute(record, location, redirectedFrom);
        }
      }
    }
    return _createRoute(null, location);
  }

  return {
    match,
    addRoutes
  };
}
```

关键点

- createRouteMap：将路由配置转换为映射表 pathMap、nameMap。
- match：根据路径或名称匹配到具体的路由记录。
- 动态路由：支持动态参数匹配和填充。

## 4. 导航守卫

导航守卫通过 beforeEach、beforeResolve、afterEach 等钩子函数实现：

```javaScript
VueRouter.prototype.beforeEach = function (fn) {
  return registerHook(this.beforeHooks, fn);
};

VueRouter.prototype.beforeResolve = function (fn) {
  return registerHook(this.resolveHooks, fn);
};

VueRouter.prototype.afterEach = function (fn) {
  return registerHook(this.afterHooks, fn);
};

function registerHook(list, fn) {
  list.push(fn);
  return function () {
    const i = list.indexOf(fn);
    if (i > -1) list.splice(i, 1);
  };
}
```

关键点

- 钩子注册：通过 registerHook 注册导航守卫。
- 钩子执行：在导航过程中按顺序执行各类钩子。
- 取消导航：通过调用 next(false) 取消导航。

## 5. 视图渲染

视图渲染通过 &lt;router-view&gt; 组件实现。根据当前路由匹配的组件进行渲染：

```javaScript
const View = {
  name: 'RouterView',
  functional: true,
  render(_, { props, children, parent, data }) {
    data.routerView = true;

    const h = parent.$createElement;
    const route = parent.$route;
    const depth = 0;
    let inactive = false;
    while (parent && parent._routerRoot !== parent) {
      const vnodeData = parent.$vnode ? parent.$vnode.data : {};
      if (vnodeData.routerView) {
        depth++;
      }
      if (vnodeData.keepAlive && parent._directInactive && parent._inactive) {
        inactive = true;
      }
      parent = parent.$parent;
    }
    data.routerViewDepth = depth;

    const matched = route.matched[depth];
    if (!matched) {
      return h();
    }

    const component = inactive
      ? matched.components.default
      : matched.components.default;

    data.registerRouteInstance = (vm, val) => {
      const current = matched.instances.default;
      if ((val && current !== vm) || (!val && current === vm)) {
        matched.instances.default = val;
      }
    };

    return h(component, data, children);
  }
};
```

关键点

- 深度计算：支持嵌套路由，通过 depth 计算嵌套层次。
- 组件渲染：根据当前路由的匹配结果渲染相应组件。
- 缓存机制：配合 keep-alive 组件实现缓存。
